
//*** package ***//
$ mvn clean package -Plocal

-- run on docker machine
##> mvn clean package -Plocal -f ./pom.xml ;wsl ./__tools.sh -p local -a deploy

//** **//
-- run in docker as sys SQLPLUS>
create user val_user identified by val_pass;

grant CREATE SESSION, ALTER SESSION, CREATE DATABASE LINK, -
  CREATE MATERIALIZED VIEW, CREATE PROCEDURE, CREATE PUBLIC SYNONYM, -
  CREATE ROLE, CREATE SEQUENCE, CREATE SYNONYM, CREATE TABLE, -
  CREATE TRIGGER, CREATE TYPE, CREATE VIEW, UNLIMITED TABLESPACE -
  to val_user;

-- run as val_user
DROP TABLE LOGS;

CREATE TABLE LOGS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY
    , TITLE VARCHAR2(120)
    , INFO VARCHAR2(1024)
    , DETAILS CLOB
    , INSERT_DATETIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
commit;

CREATE OR REPLACE PROCEDURE FLOG (
    title_in IN VARCHAR2,
    info_in IN VARCHAR2 DEFAULT NULL,
    details_in IN CLOB DEFAULT NULL
) AS
BEGIN
    INSERT INTO LOGS(TITLE, INFO, DETAILS) VALUES(title_in, info_in, details_in);

END;
/
commit;

//+++ CREATE/REPLACE PACKAGE +++//
CREATE OR REPLACE PACKAGE VN_PEGA_INTEGRATION_API AS
  -- Declare your package-level variables, types, and constants here (if any)

  -- Declare your package functions
  FUNCTION COMPONENT_GET_JSON_DATA(p1 Clob) RETURN varchar;
  FUNCTION COMPONENT_SEND_JSON_DATA(p1 Int, p2 VARCHAR) RETURN Clob;
  FUNCTION PROPERTY_GET_JSON_DATA(p1 Clob) RETURN varchar;
  FUNCTION PARSE_SUB_DIST_VALIQ(p1 Clob) RETURN Clob;
  FUNCTION PARSE_STREET_SUBURB_FROM_VALIQ(p1 Clob) RETURN Clob;

  -- Declare other package elements as needed
END VN_PEGA_INTEGRATION_API;
/


CREATE OR REPLACE PACKAGE BODY VN_PEGA_INTEGRATION_API AS
  -- Implement your package functions
  FUNCTION COMPONENT_GET_JSON_DATA(p1 Clob) RETURN varchar IS
    -- Function logic goes here
    -- You can use PL/SQL statements, variables, and other constructs
	pragma autonomous_transaction;
  BEGIN
    -- Your implementation code
    flog('FUNCTION CALL','component_get_json_data',p1);
    COMMIT;
    RETURN 'SUCCESS';
  END COMPONENT_GET_JSON_DATA;

-- Implement your package functions
  FUNCTION PROPERTY_GET_JSON_DATA(p1 Clob) RETURN varchar IS
    -- Function logic goes here
    -- You can use PL/SQL statements, variables, and other constructs
	pragma autonomous_transaction;
  BEGIN
    -- Your implementation code
    flog('FUNCTION CALL','property_get_json_data',p1);
    COMMIT;
    RETURN 'SUCCESS';
  END PROPERTY_GET_JSON_DATA;

  FUNCTION COMPONENT_SEND_JSON_DATA(p1 Int, p2 VARCHAR) RETURN Clob IS
    -- Function logic goes here
    -- You can use PL/SQL statements, variables, and other constructs
	pragma autonomous_transaction;
  BEGIN
    -- Your implementation code
    flog('FUNCTION CALL','component_send_json_data',to_char(p1,'99999')||':'||p2);
    COMMIT;
    RETURN '{"comp_id":100,"comp_code":"","comp_desc":"","district_code":"","zone_code":""}';
  END COMPONENT_SEND_JSON_DATA;

  FUNCTION PARSE_SUB_DIST_VALIQ(p1 Clob) RETURN Clob IS
    -- Function logic goes here
    -- You can use PL/SQL statements, variables, and other constructs
    pragma autonomous_transaction;
  BEGIN
    -- Your implementation code
    flog('FUNCTION CALL','parse_sub_dist_valiq',p1);
    COMMIT;
    RETURN 'SUCCESS';
  END PARSE_SUB_DIST_VALIQ;

  FUNCTION PARSE_STREET_SUBURB_FROM_VALIQ(p1 Clob) RETURN Clob IS
      -- Function logic goes here
      -- You can use PL/SQL statements, variables, and other constructs
      pragma autonomous_transaction;
    BEGIN
      -- Your implementation code
      flog('FUNCTION CALL','parse_street_suburb_from_valiq',p1);
      COMMIT;
      RETURN 'SUCCESS';
    END PARSE_STREET_SUBURB_FROM_VALIQ;
  -- Implement other package elements as needed
END VN_PEGA_INTEGRATION_API;
/
//+++ CREATE/REPLACE PACKAGE +++//

//======================================//
TESTS + DEBUG
//======================================//
SET SERVEROUTPUT ON;

declare
    v_rtn varchar2(32000);
begin

v_rtn := COMPONENT_GET_JSON_DATA('{
        "comp_id": 31521,
        "comp_code": "EL",
        "comp_desc": "ENGLOBO",
        "district_code": "1",
        "zone_code": "A",
        "ltt_category": "RES",
        "non_homogenous_ind": "Y",
        "comp_review_date": "2023/12/25 10:12:50",
        "auto_batch_exclude": "",
        "action": "CREATE",
        "action_ts": "2023/12/25 10:12:50",
        "action_by": "AAGLODIYA",
        "properties": [{"propcomp_id":4342746,
        "prop_id":508547},
        {"propcomp_id" : 7533487,
        "prop_id" : 508548}]
    }');
dbms_output.put_line('Return :' || v_rtn);
end;

=== valiq

--  SET SERVEROUTPUT ON
DECLARE
  v_connection UTL_TCP.connection;
BEGIN
  -- Replace 'hostname' and 'port' with the actual values you want to test
  /*
  v_connection := UTL_TCP.open_connection('localhost', 8092 => port_number);

  IF UTL_TCP.is_open(v_connection) THEN
    DBMS_OUTPUT.put_line('Connection successful.');
    UTL_TCP.close_connection(v_connection);
  ELSE
    DBMS_OUTPUT.put_line('Connection failed.');
  END IF;
  */
  DBMS_OUTPUT.put_line('Connection failed.');
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.put_line('Error: ' || SQLERRM);
END;
/